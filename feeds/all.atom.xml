<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Andy's blog</title><link href="https://bingfei.me/" rel="alternate"></link><link href="https://bingfei.me/feeds/all.atom.xml" rel="self"></link><id>https://bingfei.me/</id><updated>2022-01-10T10:00:00+08:00</updated><entry><title>2021 读书记录</title><link href="https://bingfei.me/blog/2022/2021-books" rel="alternate"></link><published>2022-01-10T10:00:00+08:00</published><updated>2022-01-10T10:00:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2022-01-10:/blog/2022/2021-books</id><summary type="html">&lt;p&gt;2021年读了约37本书，在读的有五六本。有些书是重读，有些书给了我很大的收获&lt;/p&gt;</summary><content type="html">&lt;h2 id="_1"&gt;读书清单&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;2021年读了约37本书，在读的有五六本（技术类书籍）（未列出）&lt;br&gt;
有些书是重读，比如《如何阅读一本书》、《月亮与六便士》、《1984》、《沙丘》等&lt;br&gt;
有些书给了我很大的收获，用加粗字体表示&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="4"&gt;4月&lt;a class="headerlink" href="#4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《史蒂夫·乔布斯传》 (2021-04-28)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="5"&gt;5月&lt;a class="headerlink" href="#5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《黑客与画家》 (2021-05-03)&lt;/li&gt;
&lt;li&gt;《思考快与慢》 (2021-05-20)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="7"&gt;7月&lt;a class="headerlink" href="#7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《&lt;strong&gt;你当像鸟飞往你的山&lt;/strong&gt;》 (2021-07-03)&lt;/li&gt;
&lt;li&gt;《&lt;strong&gt;被讨厌的勇气&lt;/strong&gt;》 (2021-07-08)&lt;/li&gt;
&lt;li&gt;《自卑与超越》 (2021-07-14)&lt;/li&gt;
&lt;li&gt;《啤博士的啤酒札记》 (2021-07-22)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="8"&gt;8月&lt;a class="headerlink" href="#8" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《&lt;strong&gt;如何阅读一本书&lt;/strong&gt;》 (2021-08-03)&lt;/li&gt;
&lt;li&gt;《非暴力沟通》 (2021-08-20)&lt;/li&gt;
&lt;li&gt;《月亮与六便士》 (2021-08-20)&lt;/li&gt;
&lt;li&gt;《富爸爸，穷爸爸》 (2021-08-24)&lt;/li&gt;
&lt;li&gt;《The Little Go Book》 (2021-08-25)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="9"&gt;9月&lt;a class="headerlink" href="#9" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《人类简史》 (2021-09-04)&lt;/li&gt;
&lt;li&gt;《未来简史》 (2021-09-09)&lt;/li&gt;
&lt;li&gt;《今日简史》 (2021-09-12)&lt;/li&gt;
&lt;li&gt;《我们这一代》 (2021-09-15)&lt;/li&gt;
&lt;li&gt;《观看之道》 (2021-09-17)&lt;/li&gt;
&lt;li&gt;《&lt;strong&gt;美丽新世界&lt;/strong&gt;》 (2021-09-18)&lt;/li&gt;
&lt;li&gt;《重返美丽新世界》 (2021-09-19)&lt;/li&gt;
&lt;li&gt;《我们》 (2021-09-25)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="10"&gt;10月&lt;a class="headerlink" href="#10" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《1984》 (2021-10-01)&lt;/li&gt;
&lt;li&gt;《&lt;strong&gt;沙丘&lt;/strong&gt;》 (2021-10-10)&lt;/li&gt;
&lt;li&gt;《沙丘救世主》 (2021-10-14)&lt;/li&gt;
&lt;li&gt;《沙丘之子》 (2021-10-19)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="11"&gt;11月&lt;a class="headerlink" href="#11" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《原则》 (2021-11-03)&lt;/li&gt;
&lt;li&gt;《穷查理宝典》 (2021-11-08)&lt;/li&gt;
&lt;li&gt;《自私的基因》 (2021-11-19)&lt;/li&gt;
&lt;li&gt;《炎拳》 *8 (2021-11-25)&lt;/li&gt;
&lt;li&gt;《大教堂与集市》 (2021-11-27)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="12"&gt;12月&lt;a class="headerlink" href="#12" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;《&lt;strong&gt;人类的群星闪耀时&lt;/strong&gt;》 (2021-12-06)&lt;/li&gt;
&lt;li&gt;《别闹了，费曼先生》 (2021-12-11)&lt;/li&gt;
&lt;li&gt;《忽悠的原理与技巧》 (2021-12-16)&lt;/li&gt;
&lt;li&gt;《万历十五年》 (2021-12-21)&lt;/li&gt;
&lt;li&gt;《童年的消逝》 (2021-12-21)&lt;/li&gt;
&lt;li&gt;《娱乐至死》 (2021-12-24)&lt;/li&gt;
&lt;li&gt;《技术垄断》 (2021-12-29)&lt;/li&gt;
&lt;li&gt;《理解一张照片：约翰·伯格论摄影》 (2021-12-31)&lt;/li&gt;
&lt;/ul&gt;</content><category term="books"></category><category term="books"></category></entry><entry><title>Redis 八股文</title><link href="https://bingfei.me/blog/2020/redis-eight-legged-essay" rel="alternate"></link><published>2020-09-30T10:00:00+08:00</published><updated>2020-09-30T10:00:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2020-09-30:/blog/2020/redis-eight-legged-essay</id><summary type="html">&lt;p&gt;简单总结 Redis 的应用，数据结构的底层实现方式，过期删除/淘汰策略，持久化，哨兵和集群的核心原理。&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#0-what-is-redis"&gt;0. What is Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#1"&gt;1. 问题列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2"&gt;2. 回答列表&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#redis-1"&gt;Redis 八股文 应用篇 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#redis-1_1"&gt;Redis 八股文 原理篇 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#redis-2"&gt;Redis 八股文 原理篇 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#redis-3"&gt;Redis 八股文 原理篇 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#redis-4"&gt;Redis 八股文 原理篇 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;附&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#1-redis"&gt;1. Redis 缓存三大问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;缓存穿透&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;缓存击穿&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;缓存雪崩&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#2_1"&gt;2. 淘汰策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#3-hyperloglog"&gt;3. Hyperloglog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="0-what-is-redis"&gt;0. What is Redis&lt;a class="headerlink" href="#0-what-is-redis" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;What makes Redis special? What types of problems does it solve? What should developers watch out for when using it? Before we can answer any of these questions, we need to understand what Redis is.&lt;/p&gt;
&lt;p&gt;Redis is often described as an in-memory persistent key-value store. I don’t think that’s an accurate description. Redis does hold all the data in memory (more on this in a bit), and it does write that out to disk for persistence, but it’s much more than a simple key-value store. It’s important to step beyond this misconception otherwise your perspective of Redis and the problems it solves will be too narrow.&lt;/p&gt;
&lt;p&gt;The reality is that Redis exposes five different data structures, only one of which is a typical key-value structure. Understanding these five data structures, how they work, what methods they expose and what you can model with them is the key to understanding Redis.&lt;/p&gt;
&lt;p&gt;—— &lt;em&gt;K. Seguin, The Little Redis Book&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是对 twitter &lt;a href="https://twitter.com/Tisoga"&gt;@Tisoga&lt;/a&gt; 所提出的一系列&lt;a href="https://twitter.com/Tisoga/status/1300717035509354496"&gt;关于 Redis 的问题&lt;/a&gt;的简单回答。如果你对下列问题或概念不甚熟悉，请阅读相关书籍。本文主要参考了下列四本书：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://openmymind.net/2012/1/23/The-Little-Redis-Book/"&gt;The Little Redis Book&lt;/a&gt; - K. Seguin (PDF, Epub) (推荐指数★★★★★，入门级，只有30页，简洁而富有启发性)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/26612779/"&gt;Redis实战&lt;/a&gt; - Josiah L. Carlson (★★★☆☆，入门级，实用，不够深入)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/30386804/"&gt;Redis 深度历险：核心原理与应用实践&lt;/a&gt; - 钱文品 (★★★★☆，基础级，应用+原理，通俗易懂)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/25900156/"&gt;Redis设计与实现&lt;/a&gt; - 黄健宏 (★★★★★，进阶级，结合源码分析底层实现和原理，深入浅出)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="1"&gt;1. 问题列表&lt;a class="headerlink" href="#1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://twitter.com/Tisoga/status/1300717035509354496"&gt;twitter 问题原文&lt;/a&gt; / &lt;a href="https://threadreaderapp.com/thread/1300717035509354496"&gt;原文 thread 问题汇总&lt;/a&gt; by twitter &lt;a href="https://twitter.com/Tisoga"&gt;@Tisoga&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Redis 八股文 应用篇 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 有哪些数据结构，分别有什么使用场景？&lt;/li&gt;
&lt;li&gt;Redis ZSET 相同 score 如何排序？&lt;/li&gt;
&lt;li&gt;在爬虫中，如何使用 Redis 做 URL 去重？&lt;/li&gt;
&lt;li&gt;Redis 是否支持事务？&lt;/li&gt;
&lt;li&gt;Redis 中的 WATCH 命令是做什么的？&lt;/li&gt;
&lt;li&gt;Redis 是如何保证高可用的？&lt;/li&gt;
&lt;li&gt;如何使用 Redis 来实现分布式锁？Redlock？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis 八股文 原理篇 1&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 是单线程还是多线程？为什么这么设计？&lt;/li&gt;
&lt;li&gt;Redis 中的字符串对象和 C 语言中的字符串有什么区别？&lt;/li&gt;
&lt;li&gt;Redis 中是如何实现链表的？&lt;/li&gt;
&lt;li&gt;Redis 中是如何实现字典的？&lt;/li&gt;
&lt;li&gt;Redis 中的字典是如何进行动态扩容的？&lt;/li&gt;
&lt;li&gt;Redis 中的跳表是如何实现的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis 八股文 原理篇 2&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STR/LIST/HASH/SET/ZSET 底层都是使用什么数据结构实现的？&lt;/li&gt;
&lt;li&gt;ZSET 什么时候使用 Ziplist 实现，什么时候使用 Skiplist 实现？&lt;/li&gt;
&lt;li&gt;ZSET 为什么不用 BST/AVL/B-Tree/红黑树，而使用跳表？&lt;/li&gt;
&lt;li&gt;Redis 的过期键删除策略是什么？&lt;/li&gt;
&lt;li&gt;Redis 的主从服务器是如何同步过期键的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis 八股文 原理篇 3&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 和 RDB 持久化有什么区别？&lt;/li&gt;
&lt;li&gt;Redis 的主从是如何进行同步的？&lt;/li&gt;
&lt;li&gt;如何解决长时间使用后 AOF 文件过大的问题？&lt;/li&gt;
&lt;li&gt;Redis 的哨兵机制是如何实现的？&lt;/li&gt;
&lt;li&gt;Redis 的集群方案有哪些？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis 八股文 原理篇 4&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 的整体架构是什么样的，从客户端发出命令，到客户端接收到结果，这整个流程是什么样的？&lt;/li&gt;
&lt;li&gt;Redis 是如何实现 LRU 机制的？&lt;/li&gt;
&lt;li&gt;Redis 是如何实现 LFU 机制的？
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="2"&gt;2. 回答列表&lt;a class="headerlink" href="#2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="redis-1"&gt;Redis 八股文 应用篇 1&lt;a class="headerlink" href="#redis-1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Redis 有哪些数据结构，分别有什么使用场景？&lt;/p&gt;
&lt;p&gt;A: Str, List, Hash, Set, Zset, Bitmap, Hyperloglog, Geo, Stream&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis ZSET 相同 score 如何排序？&lt;/p&gt;
&lt;p&gt;A: 相同 score 先插入的等效为较小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在爬虫中，如何使用 Redis 做 URL 去重？&lt;/p&gt;
&lt;p&gt;A: 使用 Set/Bloom filter。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 是否支持事务？&lt;/p&gt;
&lt;p&gt;A: 有限支持（不支持回滚）。Redis事务总是满足原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation），持久化模式下有限支持持久性（Durability）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中的 WATCH 命令是做什么的？&lt;/p&gt;
&lt;p&gt;A: WATCH 是一个乐观锁（optimistic locking），在 &lt;code&gt;EXEC&lt;/code&gt; 执行之前，监视任意数量的 key，并在 &lt;code&gt;EXEC&lt;/code&gt; 执行时，检查这些 key 是否被修改，是则拒绝执行事务，事务执行失败，空回复。&lt;/p&gt;
&lt;p&gt;实现：Redis 维护一个 &lt;code&gt;watched_keys&lt;/code&gt; 字典（值为 &lt;code&gt;client_id&lt;/code&gt; 链表），修改数据库时检查这个字典，如果发现 key 在其中，则通过 &lt;code&gt;touchWatchKey&lt;/code&gt; 函数打开对应 client 的 &lt;code&gt;REDIS_DIRTY_CAS&lt;/code&gt; 标志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 是如何保证高可用的？&lt;/p&gt;
&lt;p&gt;A: 主从（提高读）/哨兵（提供故障转移）/集群（提高读写，提供故障转移）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何使用 Redis 来实现分布式锁？Redlock？&lt;/p&gt;
&lt;p&gt;A: 分布式锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加锁：&lt;code&gt;SET my_key my_random_value NX PX expires_ms&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;拥有锁：&lt;code&gt;GET my_key == my_random_value?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;释放锁：&lt;code&gt;if 拥有锁: DEL my_key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redlock: 设置一个获取锁的 &lt;code&gt;timeout&lt;/code&gt; 常量，对多个节点进行加锁操作，如果在 &lt;code&gt;timeout&lt;/code&gt; 内获得 &lt;code&gt;N/2+1&lt;/code&gt; 个锁，则成功；否则失败，释放所有锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="redis-1_1"&gt;Redis 八股文 原理篇 1&lt;a class="headerlink" href="#redis-1_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Redis 是单线程还是多线程？为什么这么设计？&lt;/p&gt;
&lt;p&gt;A: Redis 在以前的版本中是单线程的，而在 6.0 后对 Redis 的 io 模型做了优化，io Thread 为多线程的，但是 worker Thread 仍然是单线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中的字符串对象和 C 语言中的字符串有什么区别？&lt;/p&gt;
&lt;p&gt;A: Redis 字符串使用了自定义的结构 (Simple dynamic string, SDS)，包含了字符串长度 &lt;code&gt;len&lt;/code&gt;，未分配长度 &lt;code&gt;free&lt;/code&gt;，字符数组 &lt;code&gt;buf&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;优点：常数复杂度获取字符串长度，内存安全，减少内存重分配，二进制安全，兼容部分C字符串函数。
还有两种数据结构：&lt;code&gt;int/embstr&lt;/code&gt; 分别用来存储整数和短字符串（≤32Byte）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中是如何实现链表的？&lt;/p&gt;
&lt;p&gt;A: 双向链表，由链表 &lt;code&gt;list&lt;/code&gt; / 节点 &lt;code&gt;listNode&lt;/code&gt; 组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt; 包含：头/尾节点指针、表长度、 &lt;code&gt;dup/free/comp&lt;/code&gt; 函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listNode&lt;/code&gt; 包含数据指针和 &lt;code&gt;prev/next&lt;/code&gt; 指针。头尾节点外侧指向 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中是如何实现字典的？&lt;/p&gt;
&lt;p&gt;A: 哈希表，由字典 &lt;code&gt;dict&lt;/code&gt; / 哈希表 &lt;code&gt;dictht&lt;/code&gt; / 节点数组 &lt;code&gt;dictEntry[]&lt;/code&gt; / 节点 &lt;code&gt;dictEntry&lt;/code&gt; 组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dictht&lt;/code&gt; 包含：&lt;code&gt;dictEntry&lt;/code&gt; 数组指针，表长 &lt;code&gt;size&lt;/code&gt;，掩码 &lt;code&gt;sizemask&lt;/code&gt;，已使用 &lt;code&gt;used&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dictEntry&lt;/code&gt; 保存键值对和 &lt;code&gt;next&lt;/code&gt; 指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中的字典是如何进行动态扩容的？&lt;/p&gt;
&lt;p&gt;A: &lt;code&gt;dict&lt;/code&gt; 包含两个 &lt;code&gt;ht&lt;/code&gt;，&lt;code&gt;ht[0]&lt;/code&gt; 存放哈希节点，&lt;code&gt;ht[1]&lt;/code&gt; 作为 rehash 的过度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩容/缩容：&lt;code&gt;ht[1]的size=2^n&lt;/code&gt;，且 &lt;code&gt;n = ceil(log2(ht[0]的used))&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;节点的 &lt;code&gt;idx = hash(key) &amp;amp; sizemask&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;渐进式rehash：逐步分批将 &lt;code&gt;ht[0]&lt;/code&gt; 的节点转移到&lt;code&gt;ht[1]&lt;/code&gt;。此过程中新数据只插入 &lt;code&gt;ht[1]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;rehash完成后，使用 &lt;code&gt;ht[1]&lt;/code&gt; 替换 &lt;code&gt;ht[0]&lt;/code&gt;，生成新的空 &lt;code&gt;ht[1]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 中的跳表是如何实现的？&lt;/p&gt;
&lt;p&gt;A: 由跳表 &lt;code&gt;zskiplist&lt;/code&gt; / 节点 &lt;code&gt;zskiplistNode&lt;/code&gt; 组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zskiplist&lt;/code&gt; 保存了头尾节点指针、使用层数 &lt;code&gt;level&lt;/code&gt;、表长 &lt;code&gt;length&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zskiplistNode&lt;/code&gt; 保存了层 &lt;code&gt;level&lt;/code&gt;、后退指针 &lt;code&gt;BW&lt;/code&gt;、分值 &lt;code&gt;score&lt;/code&gt;、成员对象 &lt;code&gt;obj&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;层的跨度 &lt;code&gt;level[i].span&lt;/code&gt; 表示两个节点之间的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="redis-2"&gt;Redis 八股文 原理篇 2&lt;a class="headerlink" href="#redis-2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;STR/LIST/HASH/SET/ZSET 底层都是使用什么数据结构实现的？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;STR&lt;/code&gt;: &lt;code&gt;int(long)/embstr(≤32Byte)/sds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIST&lt;/code&gt;: &lt;code&gt;ziplist(≤64 Byte, ≤512 items)/linklist/quicklist(≤8k Byte)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HASH&lt;/code&gt;: &lt;code&gt;ziplist(≤64 Byte, ≤512 items)/hashtable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SET&lt;/code&gt;: &lt;code&gt;intset(int, ≤512 items)/hashtable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZSET&lt;/code&gt;: &lt;code&gt;ziplist(≤64 Byte, ≤128 items)/skiplist&amp;amp;dict&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看编码方式：&lt;code&gt;OBJECT ENCODING key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSET 什么时候使用 Ziplist 实现，什么时候使用 Skiplist 实现？&lt;/p&gt;
&lt;p&gt;A: &lt;code&gt;ziplist(≤64 Byte, ≤128 items)/skiplist&amp;amp;dict&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZSET 为什么不用 BST/AVL/B-Tree/红黑树，而使用跳表？&lt;/p&gt;
&lt;p&gt;A: 查询复杂度相当，实现简单，支持顺序访问，提升区间读取效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的过期键删除策略是什么？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定时删除：对每个非永久的 key 设置一个 timer，到期启动删除。内存友好，CPU 不友好。&lt;/li&gt;
&lt;li&gt;惰性删除：访问时检查过期删除。内存不友好，CPU 友好。&lt;/li&gt;
&lt;li&gt;定期删除：固定时间间隔（&lt;code&gt;0.1s&lt;/code&gt;）分批（随机采样&lt;code&gt;20&lt;/code&gt;个）删除过期的 key （如果过期比例超过1/4，则重复此操作；扫描上限25ms）。平衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis 使用后两者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的主从服务器是如何同步过期键的？&lt;/p&gt;
&lt;p&gt;A: 从服务器即使发现 key 过期也不删除，并供客户端查询其值。直到主服务器删除一个过期 key 后，向所有从服务器发送一条 &lt;code&gt;DEL&lt;/code&gt; 命令，显式地删除该过期 key。由此保证主从一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="redis-3"&gt;Redis 八股文 原理篇 3&lt;a class="headerlink" href="#redis-3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;AOF 和 RDB 持久化有什么区别？&lt;/p&gt;
&lt;p&gt;A: RDB 是全量快照，不含过期 key。AOF 是将每条命令追加到文件中来记录过程，可以通过 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 避免空间浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的主从是如何进行同步的？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;sync&lt;/code&gt; 命令进行全量同步（通过发送 RDB 文件和缓冲区命令实现）（V2.8已弃用）。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;psync &amp;lt;runid&amp;gt; &amp;lt;offset&amp;gt;&lt;/code&gt; 进行全量/部分同步，通过 command propagate 进行命令传播。&lt;/li&gt;
&lt;li&gt;部分同步实现：通过主/从服务器的复制偏移量 replication offset，主服务器的复制积压缓冲区 replication backlog，服务器的运行 ID 来实现。&lt;/li&gt;
&lt;li&gt;完整步骤：&lt;ol&gt;
&lt;li&gt;slave 设置 master 的 IP/port；&lt;/li&gt;
&lt;li&gt;建立 socket 连接；&lt;/li&gt;
&lt;li&gt;Ping/Pong 测试连接；&lt;/li&gt;
&lt;li&gt;Auth 验证身份；&lt;/li&gt;
&lt;li&gt;slave 发送端口信息给 master；&lt;/li&gt;
&lt;li&gt;同步；&lt;/li&gt;
&lt;li&gt;命令传播。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何解决长时间使用后 AOF 文件过大的问题？&lt;/p&gt;
&lt;p&gt;A: AOF 重写。通过将现存的数据传给添加命令来实现，如果 key 内容过大，则按 64 items/条命令分割。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的哨兵机制是如何实现的？&lt;/p&gt;
&lt;p&gt;A: 哨兵通过 &lt;code&gt;INFO&lt;/code&gt; 命令获取主从实例网络结构，通过订阅 &lt;code&gt;__sentinel__:hello&lt;/code&gt; 频道获取哨兵网络结构。哨兵与主从实例之间建立命令和订阅连接，哨兵与哨兵之间建立命令连接。哨兵通过 &lt;code&gt;PING&lt;/code&gt; 判断节点是否在线，主观判断掉线后询问其他哨兵是否掉线来判断是否客观掉线，票数足够（&lt;code&gt;≥N/2+1&lt;/code&gt;, 基于 Raft leader election 方法实现）则视为客观掉线，发起主服务器故障转移。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 的集群方案有哪些？&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Codis。豌豆荚开发。中心化，代理模式。使用 Zookeeper/etcd 处理分布式问题（存储槽位配置等）。实现简单。提供 Dashboard 功能，Codis-fe 可以同时管理多个集群。不支持事务， &lt;code&gt;mget&lt;/code&gt; 较慢，不支持 &lt;code&gt;rename&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RedisCluster。Redis 官方实现。去中心化，对等网络。槽位配置存储在每个节点中。支持 hashtag 强制槽位。不支持事务，&lt;code&gt;mget&lt;/code&gt; 较慢，&lt;code&gt;rename&lt;/code&gt; 不是原子操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RedisCluster 实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;MEET&lt;/code&gt; 命令将节点加入集群。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;cluster addslots&lt;/code&gt; 进行槽指派。每个节点记录了16384个槽分别指派给了哪个节点（通过 &lt;code&gt;clusterState.slots&lt;/code&gt; 数组记录 &lt;code&gt;slot-&amp;gt;node&lt;/code&gt;, 通过 &lt;code&gt;slots_to_keys&lt;/code&gt; 跳表记录 &lt;code&gt;slots-&amp;gt;keys&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;redis-trib&lt;/code&gt; 对集群重分片（通过 &lt;code&gt;cluster setslot importing/migrating、cluster getkeysinslot、migrate、cluster setslot node&lt;/code&gt; 命令实现）。&lt;/li&gt;
&lt;li&gt;集群可以在检测主节点下线后指派其从节点之一代替之（类似哨兵投票）。&lt;/li&gt;
&lt;li&gt;集群通过收发消息来进行通信，类型有 &lt;code&gt;MEET/PING/PONG/PUBLISH/FAIL&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="redis-4"&gt;Redis 八股文 原理篇 4&lt;a class="headerlink" href="#redis-4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Redis 的整体架构是什么样的，从客户端发出命令，到客户端接收到结果，这整个流程是什么样的？&lt;/p&gt;
&lt;p&gt;A: 单机结构/主从结构/哨兵结构/集群结构。
流程：
1. 客户端发出命令
2. 服务端读取命令请求，并分析出命令参数
3. 命令执行器根据参数查找命令等实现函数，校验参数、认证等信息，然后执行实现函数并得出命令回复
4. 服务端将命令回复返回给客户端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 是如何实现 LRU 机制的？&lt;/p&gt;
&lt;p&gt;A: Redis 使用了近似 LRU 算法，内存超过限制后随机采样5个key，淘汰掉最旧的，留下来的 key 作为淘汰池供下一次采样比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 是如何实现 LFU 机制的？&lt;/p&gt;
&lt;p&gt;A: Redis 使用了近似 LFU 算法，使用 LRU 时间戳后8位存储访问系数（对数），并设置每分钟减一，来避免旧热点驻留。内存超过限制后随机采样5个key，淘汰掉访问系数最小的，留下来的 key 作为淘汰池供下一次采样比较。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_1"&gt;附&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="1-redis"&gt;1. Redis 缓存三大问题&lt;a class="headerlink" href="#1-redis" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="_2"&gt;缓存穿透&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;缓存穿透是指查询一条数据库和缓存都没有的一条数据，就会一直查询数据库，对数据库的访问压力就会增大，缓存穿透的解决方案，有以下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存空对象：代码维护较简单，但是效果不好。（空间占用高，一个解决的办法就是设置空对象的较短的过期时间）&lt;/li&gt;
&lt;li&gt;布隆过滤器：代码维护复杂，效果很好。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_3"&gt;缓存击穿&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;缓存击穿是指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大。
缓存击穿这里强调的是并发，造成缓存击穿的原因有以下两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）&lt;/li&gt;
&lt;li&gt;添加到了缓存，Reids 有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于缓存击穿的解决方案就是加锁。在查询缓存的时候和查询数据库的过程加锁，只能第一个进来的请求进行执行，当第一个请求把该数据放进缓存中，接下来的访问就会直接集中缓存，防止了缓存击穿。&lt;/p&gt;
&lt;h4 id="_4"&gt;缓存雪崩&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;缓存雪崩是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库。
造成缓存雪崩的原因，有以下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reids 宕机&lt;/li&gt;
&lt;li&gt;大部分数据失效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于缓存雪崩的解决方案有以下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搭建高可用的集群，防止单机的 Redis 宕机。&lt;/li&gt;
&lt;li&gt;设置不同的过期时间，防止同一时间内大量的 key 失效。&lt;/li&gt;
&lt;li&gt;缓存预热，避免系统启动初期大量缓存miss。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2_1"&gt;2. 淘汰策略&lt;a class="headerlink" href="#2_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Redis 提供了「8种的淘汰策略」&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;noeviction (默认策略)&lt;/li&gt;
&lt;li&gt;allkeys-lru&lt;/li&gt;
&lt;li&gt;volatile-lru&lt;/li&gt;
&lt;li&gt;allkeys-random&lt;/li&gt;
&lt;li&gt;volatile-random&lt;/li&gt;
&lt;li&gt;volatile-ttl&lt;/li&gt;
&lt;li&gt;volatile-lfu&lt;/li&gt;
&lt;li&gt;allkeys-lfu&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LRU (Least Recently Used)：Redis 为每个key中额外的增加一个内存空间用于存储每个key的时间，大小是3字节。&lt;/p&gt;
&lt;h3 id="3-hyperloglog"&gt;3. Hyperloglog&lt;a class="headerlink" href="#3-hyperloglog" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://blog.notdot.net/2012/09/Dam-Cool-Algorithms-Cardinality-Estimation"&gt;Damn Cool Algorithms: Cardinality Estimation - Nick's Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇讲解的通熟易懂，感兴趣的不要错过。&lt;/p&gt;</content><category term="database"></category><category term="computer"></category><category term="algorithm"></category><category term="database"></category></entry><entry><title>The Josephus Problem（约瑟夫问题）</title><link href="https://bingfei.me/blog/2019/the-josephus-problem" rel="alternate"></link><published>2019-04-21T22:00:00+08:00</published><updated>2019-04-21T22:00:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2019-04-21:/blog/2019/the-josephus-problem</id><summary type="html">&lt;p&gt;N 个人围成一圈，按顺时针方向编号，从第一位开始每次隔一个人去掉一个人，最终留下的是第几号？&lt;/p&gt;</summary><content type="html">&lt;h2 id="1"&gt;1. 约瑟夫问题&lt;a class="headerlink" href="#1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;约瑟夫问题&lt;/strong&gt;（有时也称为&lt;strong&gt;约瑟夫斯置换&lt;/strong&gt;），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为&lt;strong&gt;约瑟夫环&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。 &lt;/p&gt;
&lt;p&gt;问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。&lt;/p&gt;
&lt;p&gt;——&lt;a href="https://zh.wikipedia.org/wiki/约瑟夫斯问题"&gt;约瑟夫问题 -Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在给定人数 n、起点 1、方向顺时针、要跳过的数字 1，求应该选择初始圆圈中的什么位置以避免被处决？&lt;/p&gt;
&lt;h2 id="2"&gt;2. 模拟筛选的过程&lt;a class="headerlink" href="#2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最简单的解法，即按问题的描述直接翻译成程序求解。使用数组或单向循环链表来模拟筛选的过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;josephus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;circle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;# 使用数组&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有没有更简单的解法呢？&lt;/p&gt;
&lt;p&gt;有。&lt;/p&gt;
&lt;h2 id="3"&gt;3. 解析解&lt;a class="headerlink" href="#3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/zh-hans/解析解"&gt;解析解&lt;/a&gt;又叫公式解。在 Online Judge 系统中，如果你看到排行榜上某解法的运行时间比你的循环/递归版本快几个数量级，那么很有可能是他发现了解析解。&lt;/p&gt;
&lt;p&gt;在上述的过程中，每一圈筛选过后，人数都会&lt;strong&gt;减半&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;n&lt;/code&gt; 为偶数，那么第一圈筛选过后，剩下的位置 &lt;code&gt;p&lt;/code&gt; 上的人的编号 &lt;code&gt;q = 2p - 1&lt;/code&gt;，接下来一圈会跳过 &lt;code&gt;1&lt;/code&gt; 号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;n = 2^m&lt;/code&gt;，那么每一圈筛选后，&lt;code&gt;1&lt;/code&gt; 号都会被跳过。此种情况下，&lt;code&gt;1&lt;/code&gt; 号成为驻点，会最终留下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推广到一般情况，&lt;code&gt;n&lt;/code&gt; 可以表示成 &lt;code&gt;n = 2^m + k&lt;/code&gt; 的形式，其中 &lt;code&gt;m = floor(log(n))&lt;/code&gt;，则 &lt;code&gt;0 &amp;lt;= k &amp;lt; n/2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此时，当去掉 k 名成员后，这个问题就变成了上述第二条的情况 &lt;code&gt;2^m&lt;/code&gt;，刚才去掉的第 k 名成员的下一位成为驻点，会最终留下。&lt;/p&gt;
&lt;p&gt;由于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;k &amp;lt; n/2&lt;/code&gt;，而首轮筛选就会去掉 &lt;code&gt;n/2&lt;/code&gt; 个人，则第 k 个被去掉的人在第一轮就可以找到，编号为 &lt;code&gt;2k&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;他的下一位，&lt;code&gt;2k + 1&lt;/code&gt; 成为驻点，最终留下。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，最终留下的人编号为 &lt;code&gt;s = 2k + 1&lt;/code&gt;，其中  &lt;code&gt;n = 2^m + k&lt;/code&gt; ， &lt;code&gt;m = floor(log(n))&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;化简得 &lt;code&gt;s = 2(n - 2^( floor(log(n)) )) + 1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="4"&gt;4. 解的二进制表示&lt;a class="headerlink" href="#4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上述结果用二进制表示更加简洁，&lt;/p&gt;
&lt;p&gt;由于 n = b&lt;sub&gt;m&lt;/sub&gt;b&lt;sub&gt;m-1&lt;/sub&gt;b&lt;sub&gt;m-2&lt;/sub&gt;...b&lt;sub&gt;0&lt;/sub&gt; ，&lt;/p&gt;
&lt;p&gt;则 k = b&lt;sub&gt;m-1&lt;/sub&gt;b&lt;sub&gt;m-2&lt;/sub&gt;…b&lt;sub&gt;0&lt;/sub&gt;，&lt;/p&gt;
&lt;p&gt;幸存者编号 s = 2k + 1 = b&lt;sub&gt;m-1&lt;/sub&gt;b&lt;sub&gt;m-2&lt;/sub&gt;…b&lt;sub&gt;0&lt;/sub&gt;1 = b&lt;sub&gt;m-1&lt;/sub&gt;b&lt;sub&gt;m-2&lt;/sub&gt;...b&lt;sub&gt;0&lt;/sub&gt;b&lt;sub&gt;m&lt;/sub&gt;。&lt;/p&gt;
&lt;p&gt;即将 n 二进制中首位移到末尾即可。&lt;/p&gt;
&lt;h2 id="5"&gt;5. 新的问题&lt;a class="headerlink" href="#5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最后留下的倒数第二个人的编号是多少？&lt;/li&gt;
&lt;li&gt;当间隔不为 1 的时候，最终幸存者编号是多少？&lt;/li&gt;
&lt;/ol&gt;</content><category term="algorithm"></category><category term="computer"></category><category term="algorithm"></category><category term="maths"></category></entry><entry><title>树莓派局域网代理加速 Tetris® 99 for Nintendo Switch</title><link href="https://bingfei.me/blog/2019/raspberry-pi-as-proxy-server-in-lan" rel="alternate"></link><published>2019-02-17T17:30:00+08:00</published><updated>2019-02-17T17:30:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2019-02-17:/blog/2019/raspberry-pi-as-proxy-server-in-lan</id><summary type="html">&lt;p&gt;通过设置 privoxy over ss-local 作为局域网代理服务器，来加速 Switch 的网络连接&lt;/p&gt;</summary><content type="html">&lt;h2 id="1-tetris-99"&gt;1. Tetris® 99 的网络连接问题&lt;a class="headerlink" href="#1-tetris-99" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;任天堂在 2 月 13 日推出了一款大逃杀模式的俄罗斯方块游戏 &lt;a href="https://www.nintendo.com/games/detail/tetris-99-switch"&gt;Tetris® 99 for Nintendo Switch&lt;/a&gt;。作为一名 Tetris 老玩家，自然是不能错过。由于是在线对战游戏，对网络质量要求较高。对战过程中经常出现网络连接失败导致自动退出，气得很想摔 Switch。&lt;/p&gt;
&lt;p&gt;最简单的方法是&lt;a href="https://twitter.com/ibingfei/status/1096354236047081472"&gt;修改 Switch 网络设置的 DNS&lt;/a&gt;，但效果并不好，下载游戏很快，但对战更容易掉线。&lt;/p&gt;
&lt;p&gt;给路由器添加代理支持是个好办法，但我现在用的路由器不支持，安装插件后无法正常连接代理节点，只好另辟蹊径。&lt;/p&gt;
&lt;p&gt;Switch 的网络接入点里面有 HTTP 代理的设置项，而我的 MacBook 上有 &lt;a href="https://nssurge.com/"&gt;Surge&lt;/a&gt; 支持局域网访问，此法可行。但是这个方案需要 MacBook 一直保持在唤醒状态，休眠的话 Tetris 99 立刻掉线给你看，所以只能作为临时方案使用。&lt;/p&gt;
&lt;p&gt;正好抽屉里还有个 24 小时运行的树莓派，做局域网 HTTP 代理服务器最合适不过了。shadowsocks 是最流行的代理方式，但它的官方客户端只支持 socks5 协议的流量，因此我们还需要一个将 HTTP 流量转换为 socks5 流量的工具，&lt;a href="https://wiki.archlinux.org/index.php/Privoxy_(简体中文)"&gt;privoxy&lt;/a&gt; 可以做到。&lt;/p&gt;
&lt;h2 id="2-shadowsocks"&gt;2. 给树莓派安装 shadowsocks&lt;a class="headerlink" href="#2-shadowsocks" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先，安装 &lt;a href="https://github.com/shadowsocks/shadowsocks-libev"&gt;shadowsocks-libev&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install shadowsocks-libev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置节点信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo vim /etc/shadowsocks-libev/config.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文件格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;{
    &amp;quot;server&amp;quot;:&amp;quot;REMOTE-SERVER-IP-OR-DOMAIN&amp;quot;,
    &amp;quot;server_port&amp;quot;:&amp;quot;REMOTE-PORT&amp;quot;,
    &amp;quot;local_address&amp;quot;:&amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;local_port&amp;quot;:1080,
    &amp;quot;password&amp;quot;:&amp;quot;YOUR-PASSWORD&amp;quot;,
    &amp;quot;method&amp;quot;:&amp;quot;YOUR-METHOD&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这时运行 &lt;code&gt;ss-local&lt;/code&gt; 命令，你就可以在的前台看到节点连接情况。但当你关闭 SSH 会话时，这个进程也会停止，因此需要把它设为服务运行。&lt;/p&gt;
&lt;h3 id="ss-local"&gt;设置 &lt;code&gt;ss-local&lt;/code&gt; 服务&lt;a class="headerlink" href="#ss-local" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;编辑 &lt;code&gt;ss-local&lt;/code&gt; 服务的配置文件 &lt;code&gt;/lib/systemd/system/ss-local.service&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo vim /lib/systemd/system/ss-local.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;文件内容如下（格式参考了 &lt;code&gt;/lib/systemd/system/shadowsocks-libev.service&lt;/code&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[Unit]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;Shadowsocks-libev Default Client Service&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Documentation&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;man:ss-local&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;After&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;network.target&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;simple&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;EnvironmentFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/etc/default/shadowsocks-libev&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;User&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;nobody&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;Group&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;nogroup&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;LimitNOFILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;32768&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/ss-local -c /etc/shadowsocks-libev/config.json&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;multi-user.target&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启用 &lt;code&gt;ss-local.service&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo systemctl start ss-local.service  &lt;span class="c1"&gt;# 启动服务&lt;/span&gt;
$ sudo systemctl &lt;span class="nb"&gt;enable&lt;/span&gt; ss-local.service &lt;span class="c1"&gt;# 设置开机自启动&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在 &lt;code&gt;ss-local.service&lt;/code&gt; 服务已经成功运行了，测试一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ curl --socks5 localhost:1080 ipconfig.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你应该看到输出了远程 ss 代理节点的 IP 地址。&lt;/p&gt;
&lt;h2 id="3-privoxy-http"&gt;3. 安装 privoxy 转发 HTTP 流量&lt;a class="headerlink" href="#3-privoxy-http" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://wiki.archlinux.org/index.php/Privoxy_(简体中文)"&gt;privoxy&lt;/a&gt; 是一个 HTTP 协议过滤代理软件，安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo apt-get install privoxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改配置文件 &lt;code&gt;/etc/privoxy/config&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo vim /etc/privoxy/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在文件底部添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;forward-socks5 / 127.0.0.1:1080 . # 转发目的地址，注意末尾有一个空格和点号
listen-address  0.0.0.0:8010      # 监听局域网本机地址和端口
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;privoxy.service&lt;/code&gt; 服务在安装时已经启用，可以通过 &lt;code&gt;systemctl status privoxy.service&lt;/code&gt; 来确认，现在重启该服务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo systemctl restart privoxy.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在 &lt;code&gt;privoxy.service&lt;/code&gt; 服务已经成功运行了，测试一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ curl -x, --proxy localhost:8010 ipconfig.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你应该看到输出了远程 ss 代理节点的 IP 地址。&lt;/p&gt;
&lt;h2 id="4"&gt;4. 最后一步&lt;a class="headerlink" href="#4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;树莓派的代理服务已经成功运行，现在还需要在路由器的设置里面把树莓派的 IP 固定下来，以免每次树莓派切换 IP 还需要更改相应的 Switch 设置。&lt;/p&gt;
&lt;p&gt;如果你设置的静态 IP 和当前不一致，需要重启一下树莓派的网络服务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$ sudo ifconfig wlan0 down&lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; sudo ifconfig wlan0 up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在 Switch 的网络接入点配置里添加代理的 IP （树莓派的静态 IP）和端口号 8010，保存并重新连接此接入点，提示连接成功，即可开始体验 Tetris® 99 了。&lt;/p&gt;
&lt;p&gt;彩蛋：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Tetris® 99 screenshot" src="https://pbs.twimg.com/media/DznlORWU8AELB0h.jpg"&gt;&lt;/p&gt;</content><category term="linux"></category><category term="linux"></category><category term="raspberrypi"></category></entry><entry><title>IEEE 754 与 9999999999999999.0 - 9999999999999998.0 == 2.0</title><link href="https://bingfei.me/blog/2019/IEEE-754-and-9999999999999999.0-9999999999999998.0-2.0" rel="alternate"></link><published>2019-01-06T22:25:00+08:00</published><updated>2019-01-06T22:25:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2019-01-06:/blog/2019/IEEE-754-and-9999999999999999.0-9999999999999998.0-2.0</id><summary type="html">&lt;p&gt;为什么大多数编程语言计算 9999999999999999.0 - 9999999999999998.0 的结果是 2.0？因为 &lt;code&gt;IEEE 754&lt;/code&gt;。&lt;/p&gt;</summary><content type="html">&lt;h2 id="1"&gt;1. 计算机算错了吗？&lt;a class="headerlink" href="#1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天在 Twitter 上看到这样一条 &lt;a href="https://twitter.com/nixcraft/status/1081806050708283397"&gt;tweet&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s a simple question:&lt;/p&gt;
&lt;p&gt;9999999999999999.0 - 9999999999999998.0&lt;/p&gt;
&lt;p&gt;Does your favorite language give the right answer? &lt;a href="http://geocar.sdf1.org/numbers.html"&gt;http://geocar.sdf1.org/numbers.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然是等于 1 嘛～&lt;/p&gt;
&lt;p&gt;然而大多数编程语言都没有得出正确答案——它们得出的结果是 &lt;code&gt;2.0&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="right"&gt;language&lt;/th&gt;
&lt;th align="left"&gt;output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="right"&gt;C:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;main(){printf("%lf\n",(double)9999999999999999.0-9999999999999998.0);}&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.000000&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;Java:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;public class Foo{public static void main(String args[]){System.out.println(9999999999999999.0-9999999999999998.0);}}&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.0&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;Python:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 9999999999999999.0 - 9999999999999998.0&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.0&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;Javascript:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;9999999999999999.0 - 9999999999999998.0&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.0&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;GoLang:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;var a = 9999999999999999.0; var b = 9999999999999998.0; fmt.Printf("%f\n", a-b)&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.000000&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;Ruby:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;irb(main):001:0&amp;gt; 9999999999999999.0 - 9999999999999998.0&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2.0&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="right"&gt;R:&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;&amp;gt; 9999999999999999.0-9999999999999998.0 [1]&lt;/code&gt; &lt;br&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;WHY?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;IEEE 754&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="2-ieee-754"&gt;2. IEEE 754&lt;a class="headerlink" href="#2-ieee-754" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;IEEE Standard for Floating-Point Arithmetic&lt;/strong&gt; (&lt;strong&gt;IEEE 754&lt;/strong&gt;) is a &lt;a href="https://en.wikipedia.org/wiki/Technical_standard"&gt;technical standard&lt;/a&gt; for &lt;a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic"&gt;floating-point arithmetic&lt;/a&gt; established in 1985 by the &lt;a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers"&gt;Institute of Electrical and Electronics Engineers&lt;/a&gt; (IEEE). via &lt;a href="https://en.wikipedia.org/wiki/IEEE_754"&gt;en.wikipedia.org/wiki/IEEE_754&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1985 年，电气电子工程师协会（&lt;a href="https://zh.wikipedia.org/zh-cn/电气电子工程师协会"&gt;IEEE&lt;/a&gt;）制定了浮点数算数标准——IEEE 754，为许多CPU与浮点运算器所采用。IEEE 754 规定了四种表示浮点数值的方式：单精度（32位）、双精度（64位）、延伸单精度（43位以上，很少使用）与延伸双精度（79位以上，通常以80位实现）。现代的编程语言通常采用双精度（64位）进行浮点数算数运算。&lt;/p&gt;
&lt;h3 id="21"&gt;2.1 浮点数实现&lt;a class="headerlink" href="#21" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zh.wikipedia.org/wiki/IEEE_754#浮點數剖析"&gt;浮点数在计算机内部以二进制数表示&lt;/a&gt;，其结构如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Value = sign × exponent × fraction&lt;/code&gt; （&lt;code&gt;值 = 符号位 * 指数偏移值 * 分数值&lt;/code&gt;） &lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;符号位：正为 0，负为 1。&lt;/li&gt;
&lt;li&gt;指数偏移值：即浮点数表示法中指数域的编码值，等于指数的实际值加上某个固定的值，IEEE 754 标准规定该固定值为 &lt;code&gt;2^(e - 1) - 1​&lt;/code&gt;，其中 e 为指数偏移值部分的长度。&lt;/li&gt;
&lt;li&gt;编码范围为 &lt;code&gt;0 &amp;lt;= exponent &amp;lt;= 2^e - 1&lt;/code&gt;，实际取值范围为 &lt;code&gt;-2^(e - 1) - 2 &amp;lt;= exponent &amp;lt;=  2^(e - 1) - 1&lt;/code&gt;​。​ &lt;code&gt;-2^(e - 1) - 1&lt;/code&gt; ​和 &lt;code&gt;2^(e - 1)&lt;/code&gt; 被用作特殊处理，见下方「非规约形式的浮点数」和「特殊值」。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分数值：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;规约形式的浮点数&lt;/strong&gt;：如果浮点数中指数部分的编码值在 &lt;code&gt;0 &amp;lt; exponent &amp;lt;= 2^{e}-2&lt;/code&gt; 之间，且在科学表示法的表示方式下，分数 (fraction) 部分最高有效位（即整数位）是 1，那么这个浮点数将被称为规约形式的浮点数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据定义，规约形式的浮点数中，分数部分第一位必为整数 1，故此 1 可以省去，只留小数部分，由此可以多存一位有效数字。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非规约形式的浮点数&lt;/strong&gt;：如果浮点数的指数部分的编码值是 0，分数部分非零，那么这个浮点数将被称为非规约形式的浮点数。一般是某个数字&lt;strong&gt;相当&lt;/strong&gt;接近零时才会使用非规约型式来表示。 此时，0 表示 &lt;code&gt;-2^(e - 1) - 2&lt;/code&gt; 而不是 &lt;code&gt;-2^(e - 1) - 1&lt;/code&gt;，以此来解决&lt;strong&gt;突然式下溢出&lt;/strong&gt;（abrupt underflow）问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在使用 32 位存储的浮点数中，符号位占 1 位，指数偏移值占 8 位，分数值占 23 位。&lt;/p&gt;
&lt;p&gt;在使用 64 位存储的浮点数中，符号位占 1 位，指数偏移值占 11 位，分数值占 52 位。（如图所示：）&lt;/p&gt;
&lt;p&gt;&lt;img alt="IEEE 754 双精度浮点数" src="https://upload.wikimedia.org/wikipedia/commons/a/a9/IEEE_754_Double_Floating_Point_Format.svg"&gt;&lt;/p&gt;
&lt;h4 id="211-ieee-754"&gt;2.1.1 IEEE 754 规定了三个特殊值：&lt;a class="headerlink" href="#211-ieee-754" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;em&gt;指数&lt;/em&gt;是 0 并且尾数的&lt;em&gt;小数部分&lt;/em&gt;是 0，这个数是 ±0（和符号位相关）&lt;/li&gt;
&lt;li&gt;如果&lt;em&gt;指数&lt;/em&gt; = &lt;code&gt;2^(e - 1)&lt;/code&gt; 并且尾数的&lt;em&gt;小数部分&lt;/em&gt;是 0，这个数是 ±&lt;a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%A9%B7%E5%A4%A7"&gt;∞&lt;/a&gt;（同样和符号位相关）&lt;/li&gt;
&lt;li&gt;如果&lt;em&gt;指数&lt;/em&gt; = &lt;code&gt;2^(e - 1)&lt;/code&gt; 并且尾数的&lt;em&gt;小数部分&lt;/em&gt;非 0，这个数表示为&lt;a href="https://zh.wikipedia.org/wiki/NaN"&gt;不是一个数（NaN）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="22"&gt;2.2 双精度有多精确？&lt;a class="headerlink" href="#22" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;双精度的&lt;strong&gt;分数部分共有 52 位&lt;/strong&gt;，加上规约形式前面省略的 1 位，因此共有 53 位二进制精度。&lt;/p&gt;
&lt;p&gt;能表示的最大数值（在不考虑指数部分的情况下）为：&lt;code&gt;2^53 - 1 = 9007199254740991&lt;/code&gt; （十进制，共 16 位有效数字）。&lt;/p&gt;
&lt;p&gt;超过精度的数值会被舍入，IEEE 754 默认的舍入规则为&lt;strong&gt;就近舍入&lt;/strong&gt;，即舍入到最近的偶数——二进制下末位为 0 的数值。&lt;/p&gt;
&lt;h3 id="23-99999999999999990-99999999999999980"&gt;2.3 双精度浮点数表示 &lt;code&gt;9999999999999999.0&lt;/code&gt; 和 &lt;code&gt;9999999999999998.0&lt;/code&gt;&lt;a class="headerlink" href="#23-99999999999999990-99999999999999980" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;考察 &lt;code&gt;9999999999999999&lt;/code&gt; 和 &lt;code&gt;9999999999999998&lt;/code&gt; 的二进制形式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9999999999999999&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9999999999999998&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0b100011100001101111001001101111110000001111111111111111&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;# 二进制共 54 位&lt;/span&gt;
     &lt;span class="s1"&gt;&amp;#39;0b100011100001101111001001101111110000001111111111111110&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 同上&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二进制共 54 位，规约后省略首位，仍有 53 位&lt;/p&gt;
&lt;h4 id="231-99999999999999990"&gt;2.3.1 &lt;code&gt;9999999999999999.0&lt;/code&gt;:&lt;a class="headerlink" href="#231-99999999999999990" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999999&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用二进制表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="mf"&gt;100011100001101111001001101111110000001111111111111111&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="err"&gt;└─────────────────────────┬──────────────────────────┘&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="mf"&gt;54&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999999.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;科学表示法表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mf"&gt;53&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;×&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.00011100001101111001001101111110000001111111111111111&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="err"&gt;└───────────────────────┬──────────────────────────┘│&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="mf"&gt;52&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="n"&gt;超出&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;舍去最后一位&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;并进一位&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999999.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用双精度浮点数表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0100001101000001110000110111100100110111111000001000000000000000&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="err"&gt;│└────┬────┘└────────────────────────┬─────────────────────────┘&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exp&lt;/span&gt;&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="mf"&gt;52&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;等于&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;10000000000000000&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;即&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mf"&gt;16&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="232-99999999999999980"&gt;2.3.2 &lt;code&gt;9999999999999998.0&lt;/code&gt;:&lt;a class="headerlink" href="#232-99999999999999980" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999998&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用二进制表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="mf"&gt;100011100001101111001001101111110000001111111111111110&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="err"&gt;└─────────────────────────┬──────────────────────────┘&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="mf"&gt;54&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999998.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;科学表示法表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="mf"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mf"&gt;53&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;×&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.00011100001101111001001101111110000001111111111111110&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="err"&gt;└───────────────────────┬──────────────────────────┘│&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;&lt;span class="mf"&gt;52&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;超出&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;舍入&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="n"&gt;舍去最后一位&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="mf"&gt;3.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999998.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;用双精度浮点数表示为&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0100001101000001110000110111100100110111111000000111111111111111&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="err"&gt;│└────┬────┘└────────────────────────┬─────────────────────────┘&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;exp&lt;/span&gt;&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="mf"&gt;52&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;等于&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9999999999999998&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="n"&gt;即&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9.999999999999998e+15&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="24-99999999999999990-99999999999999980"&gt;2.4 双精度浮点数表示 &lt;code&gt;9999999999999999.0 - 9999999999999998.0&lt;/code&gt;&lt;a class="headerlink" href="#24-99999999999999990-99999999999999980" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因此，在双精度浮点数表示下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;   9999999999999999.0 - 9999999999999998.0
= 10000000000000000.0 - 9999999999999998.0
= 2.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也就可以理解了。&lt;/p&gt;
&lt;h2 id="_1"&gt;最后&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;二进制可以精确地表示绝大部分常见的 10 进制整数，但无法精确地表示大部分常见的 10 进制小数（仅能精确表示&lt;a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%86%E6%95%B0"&gt;二进分数&lt;/a&gt;  &lt;code&gt;m/2^n&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;0.1 + 0.2 == 0.30000000000000004&lt;/code&gt; 也是困扰无数计算机新手的经典问题。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;双精度浮点数表示&lt;/th&gt;
&lt;th&gt;实际值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;0x3FB999999999999A&lt;/td&gt;
&lt;td&gt;0.100000000000000005551115123126&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;0x3FC999999999999A&lt;/td&gt;
&lt;td&gt;0.200000000000000011102230246252&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;td&gt;0x3FD3333333333333&lt;/td&gt;
&lt;td&gt;0.299999999999999988897769753748&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Well, nobody's perfect. - &lt;em&gt;&lt;a href="https://movie.douban.com/subject/1292574/"&gt;Some Like It Hot (1959)&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><category term="computer"></category><category term="computer"></category></entry><entry><title>树莓派3零附件配置 Wi-Fi 和 SSH</title><link href="https://bingfei.me/blog/2018/raspberry-pi-3-setup" rel="alternate"></link><published>2018-01-03T17:30:00+08:00</published><updated>2018-01-03T17:30:00+08:00</updated><author><name>Andy</name></author><id>tag:bingfei.me,2018-01-03:/blog/2018/raspberry-pi-3-setup</id><summary type="html">&lt;p&gt;在没有外接键盘和显示器的条件下，配置树莓派通过 Wi-Fi 进行 SSH 登录&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://raspberrypi.org/"&gt;树莓派&lt;/a&gt;是一款基于 Linux 的单片机，由于体积小巧，价格低廉，可以用来学习 Linux 系统，编写并运行小型应用，做&lt;a href="https://kodi.tv/"&gt;家庭影音服务中心&lt;/a&gt;等。&lt;/p&gt;
&lt;p&gt;几天前朋友送给我一块&lt;a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/"&gt;树莓派 3B&lt;/a&gt;，拥有四核 1.2GHz 64 位 ARM CPU，1GB LPDDR2 内存，四个 USB 2.0 接口，一个 MicroSD 卡槽，一个百兆以太网接口，支持 Wi-Fi 802.11n 和 蓝牙 4.1。&lt;/p&gt;
&lt;h2 id="1"&gt;1. 安装系统&lt;a class="headerlink" href="#1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;树莓派官方的操作系统 &lt;a href="https://www.raspberrypi.org/downloads/raspbian/"&gt;Raspbian&lt;/a&gt; 有三个版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raspbian with desktop and recommended software&lt;/li&gt;
&lt;li&gt;Raspbian with desktop&lt;/li&gt;
&lt;li&gt;Raspbian Lite&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我安装的是非桌面版本 Raspbian Lite，通过烧录工具 &lt;a href="https://www.tweaking4all.com/software/macosx-software/macosx-apple-pi-baker/"&gt;ApplePi-Baker&lt;/a&gt; for macOS 把下载好的镜像文件&lt;a href="https://sspai.com/post/38542"&gt;写入 SD 卡&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="2-ssh"&gt;2. 启用 SSH&lt;a class="headerlink" href="#2-ssh" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;几乎所有的教程都会要求使用外接键盘和显示器连接树莓派进行接下来的操作。如果没有这些附件怎么办呢？办法是有的。&lt;/p&gt;
&lt;p&gt;SSH 默认状态下是关闭的，启用的方法是在 Raspbian 系统目录 &lt;code&gt;/mnt/sdc1&lt;/code&gt; 下创建一个名为 &lt;code&gt;ssh&lt;/code&gt; 的空文件。&lt;/p&gt;
&lt;h2 id="3-wi-fi"&gt;3. 启用自动连接 Wi-Fi&lt;a class="headerlink" href="#3-wi-fi" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在启用 SSH 的情况下，可以通过网络连接树莓派，比如网线或者 Wi-Fi。如果你恰好和我一样没有网线，或者只是讨厌给树莓派多插一条线的话，还可以通过 Wi-Fi 进行连接。&lt;/p&gt;
&lt;p&gt;Wi-Fi 默认状态也是关闭的，幸运的是我找到了这个&lt;a href="https://raspberrypi.stackexchange.com/questions/37920/how-do-i-set-up-networking-wifi-static-ip-address/37921#37921"&gt;帖子&lt;/a&gt;，里面介绍了在烧录系统后直接配置 Wi-Fi 的方法。&lt;/p&gt;
&lt;p&gt;Raspbian 在启动时会检查 &lt;code&gt;/boot&lt;/code&gt; 目录下的 &lt;code&gt;wpa_supplicant.conf&lt;/code&gt; 文件并把它移动到 &lt;code&gt;/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code&gt; （如果文件已存在则会被覆盖），可以在这里进行 Wi-Fi 连接的参数配置。&lt;/p&gt;
&lt;p&gt;在 Raspbian 根目录下新建 &lt;code&gt;wpa_supplicant.conf&lt;/code&gt; 文件并添加进下面几行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;ctrl_interface&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;DIR&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;wpa_supplicant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GROUP&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;netdev&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;update_config&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;network&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ssid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SSID&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;psk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;PASSWORD&amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，替换 &lt;code&gt;SSID&lt;/code&gt; 和 &lt;code&gt;PASSWORD&lt;/code&gt; 为你希望连接的 Wi-Fi 名称和密码。&lt;/p&gt;
&lt;h2 id="4-wi-fi-ssh"&gt;4. 运行树莓派并通过 Wi-Fi 进行 SSH 登录&lt;a class="headerlink" href="#4-wi-fi-ssh" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;现在你可以把树莓派插卡通电放到角落里了。在终端中输入 &lt;code&gt;ssh pi@raspberrypi.local&lt;/code&gt; 进行登录，使用 &lt;code&gt;raspberry&lt;/code&gt; 作为初始密码。现在你应该已经登入了树莓派，可以按照自己的想法使用它了。&lt;/p&gt;
&lt;p&gt;希望这篇文章对你有所帮助。&lt;/p&gt;</content><category term="linux"></category><category term="linux"></category><category term="raspberrypi"></category></entry></feed>